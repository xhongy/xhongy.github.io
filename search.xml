<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title>断点续传</title>
    <url>/2020/04/19/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</url>
    <content><![CDATA[<h3 id="什么是断点续传："><a href="#什么是断点续传：" class="headerlink" title="什么是断点续传："></a>什么是断点续传：</h3><blockquote>
<p>说得白一点，<em>其实也</em>就是下载文件时，不必重头开始下载，而是从指定的位置继续下载，这样的功能就叫做断点续传。<br>既然如此，那么要实现断点续传的关键点其实也就是两点：</p>
</blockquote>
<ul>
<li>如何告知服务端，从指定的位置下载</li>
<li>如何知道客户端想要的指定位置是多少</li>
</ul>
<p>其实，很简单，并不需要我们自己去写一些什么，HTTP 协议本身就支持断点续传，<br>而且文件是下载到客户端设备上的，那么只要获取到这份下载到一半的文件，<br>看一下它目前的大小，也就知道需要让服务端从哪开始继续下载了。</p>
<p>那么，下面就介绍一下涉及到的相关理论</p>
<h3 id="Range-amp-Content-Length-amp-Content-Range-amp-If-Range"><a href="#Range-amp-Content-Length-amp-Content-Range-amp-If-Range" class="headerlink" title="Range &amp; Content-Length &amp; Content-Range &amp; If-Range"></a>Range &amp; Content-Length &amp; Content-Range &amp; If-Range</h3><p>这些都是 HTTP 包中 Header 头部的一些字段信息，其中 Range 和 If-Range 是请求头中<br>其中 Range 和 If-Range 是请求头中的字段，Content-Length 和 Content-Range 是响应头中的字段。</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>当请求头中出现 Range 字段时，表示告知服务端，客户端下载该文件想要从指定的位置开始下载，至于 Range 字段属性值的格式有以下几种：</p>
<p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range:bytes&#x3D;0-500  表示下载从0到500字节的文件，即头500个字节</span><br><span class="line"></span><br><span class="line">Range:bytes&#x3D;501-1000  表示下载从500到1000这部分的文件，单位字节</span><br><span class="line"></span><br><span class="line">Range:bytes&#x3D;-500   表示下载最后的500个字节</span><br><span class="line"></span><br><span class="line">Range:bytes&#x3D;500-   表示下载从500开始到文件结束这部分的内容</span><br></pre></td></tr></table></figure>
<p>如果 app 想实现断点续传，文件下载到一半被迫中断，下次启动还可以继续接着上次<br>进度下载时，那么此时可以使用 Range:bytes=500- 这种格式了，只要先获取本地那<br>份文件目前的大小，通过在请求头中加入 Range 字段信息即可</p>
<h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>Content-Length 字段出现在响应头中，用于告知客户端此次下载的文件大小。</p>
<p>一般，如果客户端需要实现下载进度实时更新时，就需要知道文件的总大小和目前下载的大小，后者可以通过对本地文件的操作得知，前者一般就是通过响应头中的 Content-Length 字段得知。</p>
<p>另外，如果想要实现多线程同时分段下载大文件功能时，显然在下载前，客户端需要先知道文件总大小，才可以做到动态进行分段，因此一般在下载前都会先发送一个不需要携带 body 信息请求，用于先获取响应头中的 Content-Length 字段来得知文件总大小。</p>
<p>但有一点需要注意：Content-Length 只表示此链接中下载的文件大小</p>
<p>什么意思，也就是说，如果这条链接是一次性将整个文件下载下来的，那么 Content-Length 就表示这个文件的总大小。</p>
<p>但，如果这条链接指定了 Range，表明了只是下载文件的指定部分的内容，那么此时 Content-Length 表示的就只是这一部分的大小。</p>
<p>所以，如果客户端实现了下载进度实时更新功能时，需要注意一下。因为如果文件是断点续传的，那么进度条的分母就不能用每次 HTTP 链接中的 Content-Length。要么下载前先发一条获取用于文件总大小的请求，然后一直维护着这个数据，要么就使用 Content-Range 字段。</p>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p>Content-Range 字段也是出现在响应头中，用于告知客户端此链接下载的文件是哪个部分的，以及文件的总大小。<br>比如，当客户端在请求头中指定了 Range:bayes=501-1000 来下载一个总大小为 2000 字节文件的中间一部分内容时，此时，响应头中的 Content-Range 字段信息如下：<br>Content-Range:bytes 501-1000/2000<br>斜杠前表示此链接下载的文件是哪一部分，斜杠后表示文件的总大小。</p>
<h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p>断点续传，说白点也就是分多次下载，既然不是一次性下载，那么就无法保证多次下载的间隔。<br>也就是说，有可能出现这种场景，这次由于某些原因只下载的一部分，而下次重启继续下载，但可能等到过了很多天后才重启去继续下载，如果在这期间，服务端的这份文件更新了怎么办？<br>只要不是一次性下载的，那么就有可能会出现这种场景，显然，这时候，就不希望断点续传了，而是要让客户端直接重头开始下载，毕竟文件都已经发生更新了，不是同一份了，再继续恢复下载也没有什么意义。<br>那么，客户端要如何知道服务端的文件是否发生变化，要重头下载呢？<br>这时就可以结合 If-Range 字段来实现了，这个也是在请求头中的字段，跟 Range 字段一起使用，它的作用是给 Range<br>字段生效设置了一些条件，只有满足这些条件，Range 才能生效。<br>也就是说，只有先满足 If-Range，那么才能通过 Range 来实现断点续传。<br>那它的条件值可以设置为哪些呢？有两种，Last-Modified 或者 ETag，这两个也都是响应头中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.header(&quot;Content-Length&quot;) &#x2F;&#x2F; 文件长度</span><br><span class="line">response.header(&quot;Last-Modified&quot;)  &#x2F;&#x2F; 修改时间</span><br><span class="line">response.header(&quot;ETag&quot;)      &#x2F;&#x2F;ETag标识</span><br></pre></td></tr></table></figure>

<h3 id="代码查看"><a href="#代码查看" class="headerlink" title="代码查看"></a>代码查看</h3><p>本人已采用okhttp框架实现了此功能，代码已上传至github，地址：</p>
<p><a href="https://github.com/xhongy/OkHttpLib" target="_blank" rel="noopener">https://github.com/xhongy/OkHttpLib</a></p>
<p>同时插件也上传了jcenter，想使用此插件的友友们，可以访问一下地址查看详情</p>
<p><a href="https://bintray.com/beta/#/xhongy/maven/OkHttpPlugin" target="_blank" rel="noopener">https://bintray.com/beta/#/xhongy/maven/OkHttpPlugin</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>断点续传</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>通过bintray-release，发布库到Jcenter</title>
    <url>/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/</url>
    <content><![CDATA[<blockquote>
<p>android开发时有时候需要用到一些第三方的库，只需要<strong>implementation ‘com.orhanobut:logger:2.2.0’</strong>,简单的一条语句引入即可，是不是感觉好神奇。<br>现在很多时候开发都是组件化的模式，如果能把公共部分做成开源库供大家使用那就方便多了，加下来我就以上传android的一个moudule为例一步一步教大家如何来操作。</p>
</blockquote>
<p>本文是通过bintray-release 来操作的，先了解一下bintray-release是什么？</p>
<ul>
<li>bintray-release是github上的一个开源工程库。</li>
<li>bintray-release提供了将您的Android或者其他作品推送到Bintray的简便方案。</li>
<li>bintray-release是帮助将类库推送到bintray的助手。 它用来帮助配置与maven和bintray建立联系。 目前它用于Android Library工程，Java项目以及Groovy项目，但其重点主要是用来支持Android项目。</li>
</ul>
<p><strong>接下来开始美妙的编程时刻吧！LET’S GO!!</strong></p>
<h3 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h3><p>在AndroidStudio上建android Project，然后新建一个module，结果如下<br><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/new-pro-suc.png"  alt></p>
<h3 id="调试module"><a href="#调试module" class="headerlink" title="调试module"></a>调试module</h3><p>接下来编写新建的module块代码，并将此module作为app模块的依赖，调试成功。<br>这里仅仅添加一条打印日志</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/module-class.png"  alt></p>
<h3 id="module代码上传github"><a href="#module代码上传github" class="headerlink" title="module代码上传github"></a>module代码上传github</h3><p> 将调试成功的module块代码上传到github仓库(代码中转库)<br>此步骤可参考另一篇相关帖子,</p>
<blockquote>
<p><a href="https://xhongy.github.io/2020/04/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0github/">github上传文件</a></p>
</blockquote>
<h3 id="module上传jcenter"><a href="#module上传jcenter" class="headerlink" title="module上传jcenter"></a>module上传jcenter</h3><p><strong>关键步骤，要放大招了</strong></p>
<h4 id="注册bintray账号"><a href="#注册bintray账号" class="headerlink" title="注册bintray账号"></a>注册bintray账号</h4><p>这里是通过bintray-release中转站，没有bintray账号的先注册一个账号</p>
<blockquote>
<p><a href="https://bintray.com/signup/oss" target="_blank" rel="noopener">注册地址</a><br>可以直接注册或者通过Github帐号注册。具体步骤自行操作，不做过多讲述了。</p>
</blockquote>
<h4 id="bintray新建仓库"><a href="#bintray新建仓库" class="headerlink" title="bintray新建仓库"></a>bintray新建仓库</h4><p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/new-repository.png"  alt></p>
<p>点击<strong>Add New Repository</strong>，进入新建仓库配置页面</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/info-repository.png"  alt></p>
<h3 id="获取API-KEY"><a href="#获取API-KEY" class="headerlink" title="获取API-KEY"></a>获取API-KEY</h3><p>获取API KEY，在头像下选择 Edit Profile 进入新页面可以看到API KEY然后复制保存备用；</p>
<p>可以点击show查看key或者直接点击右侧的复制按钮复制</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/get-api-key.png"  alt></p>
<p>到此，所有的准备功能已经准备完毕！接下来就要进入到ANDROID STUDIO 中进行代码的一些配置；</p>
<h3 id="AndroidStudio代码配置"><a href="#AndroidStudio代码配置" class="headerlink" title="AndroidStudio代码配置"></a>AndroidStudio代码配置</h3><h4 id="工程-根目录-build-gradle中添加"><a href="#工程-根目录-build-gradle中添加" class="headerlink" title="工程(根目录)build.gradle中添加"></a>工程(根目录)build.gradle中添加</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        jcenter()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath <span class="string">'com.novoda:bintray-release:0.8.1'</span> // 添加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在待发布的module中的build-gradle添加"><a href="#在待发布的module中的build-gradle添加" class="headerlink" title="在待发布的module中的build.gradle添加"></a>在待发布的module中的build.gradle添加</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.novoda.bintray-release'</span></span><br><span class="line">publish &#123;</span><br><span class="line">    userOrg = <span class="string">'yourUserName'</span>                 //bintray注册的用户名</span><br><span class="line">    groupId = <span class="string">'com.github.sunrise'</span>           //compile引用时的第1部分</span><br><span class="line">    artifactId = <span class="string">'Test'</span>                      //compile引用时的第2部分                                     </span><br><span class="line">    publishVersion = <span class="string">'1.0.0'</span>                 //版本号</span><br><span class="line">    repoName = yourRepositoryName         //你要上传至bintray仓库的名称，如果仓库名称是maven可忽略</span><br><span class="line">    desc = <span class="string">'anything you want'</span>               //描述</span><br><span class="line">    website = <span class="string">'anything you want'</span>            //网站</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="上传到bintray"><a href="#上传到bintray" class="headerlink" title="上传到bintray"></a>上传到bintray</h4><p> 在androidStudio的Terminal中输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gradlew clean build bintrayUpload -PbintrayUser=yourUserName -PbintrayKey=yourAPIKEY -PdryRun=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文中的yourUserName替换为你注册binary的用户名，yourAPIKEY替换为你的key.</p>
</blockquote>
<p>稍后出现BUILD SUCCESSFUL即上传成功<br><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/gradlew-suc.png"  alt></p>
<p>截止到此时，我们已经成功的把module 上传到了 bintray 的 Respository中。</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/bintray-new-rep.png"  alt></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>此时若要引用此库，需要在项目根build.gradle文件下加入想要的maven库依赖</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/lib-use.png"  alt></p>
<p>在需要引用的库里添加想要的implenmention</p>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>若开放给别人使用每次都添加maven依赖是不是太麻烦，那就需要同步到Jcenter，操作如下图，耐心等待审核(注：版本升级不用再次同步到Jcenter)</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/add-to-jcenter.png"  alt></p>
<p>等待审核通过，就ok了！！</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E9%80%9A%E8%BF%87bintray-release%EF%BC%8C%E5%8F%91%E5%B8%83%E5%BA%93%E5%88%B0Jcenter/end.png"  alt><br>这是在项目中只通过implemention来使用就ok</p>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h4 id="错误-编码GBK的不可映射字符。"><a href="#错误-编码GBK的不可映射字符。" class="headerlink" title="错误: 编码GBK的不可映射字符。"></a>错误: 编码GBK的不可映射字符。</h4><p>解决办法：在项目根build.gradle中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    &#x2F;&#x2F;编译时报注释GBK编码错误解决</span><br><span class="line">    tasks.withType(Javadoc) &#123;</span><br><span class="line">        options.addStringOption(&#39;encoding&#39;, &#39;UTF-8&#39;)</span><br><span class="line">        options.addStringOption(&#39;charSet&#39;, &#39;UTF-8&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="return或-param不能为空"><a href="#return或-param不能为空" class="headerlink" title="@return或@param不能为空"></a>@return或@param不能为空</h4><p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    &#x2F;&#x2F;编译时报注释GBK编码错误解决</span><br><span class="line">    tasks.withType(Javadoc) &#123;</span><br><span class="line">        &#x2F;&#x2F;方法上忽略@return和@param注解未添加说明注释</span><br><span class="line">        options.addStringOption(&#39;Xdoclint:none&#39;, &#39;-quiet&#39;)</span><br><span class="line">        &#x2F;&#x2F;解决GBK编码错误提示</span><br><span class="line">        options.addStringOption(&#39;encoding&#39;, &#39;UTF-8&#39;)</span><br><span class="line">        options.addStringOption(&#39;charSet&#39;, &#39;UTF-8&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h3><p>如果需要更新升级的时候，更新完代码只需要把module里面的publishVersion更新到自己的版本<br>如1.0.0 —-&gt;1.0.1<br>然后在次执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gradlew clean build bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxx -PdryRun=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>那么在引入的时候改变版本号即可使用最新代码。</p>
<blockquote>
<p>注意：第一次上传的时候需要add to jcenter, 后面更新只需要在命令行提交到bintary即可。</p>
</blockquote>
<h3 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h3><p>在使用中有可能会出现各种问题，可参考<br><a href="https://www.jianshu.com/p/6b272fe9bd28" target="_blank" rel="noopener">转载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>jcenter</tag>
        <tag>marven</tag>
        <tag>bintray</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化</title>
    <url>/2020/04/21/%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<p>组件化： gradle 开发中<br>插件化： 动态化：反射、类加载 运行中</p>
<blockquote>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>hexo+github搭建个人博客</title>
    <url>/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>本人程序员一枚，自从开始从事本行就心心念念的想搞一个自己的博客，怎奈有心无行动。<br>最近恍然一悟，最好的行动的时间永远都是当下，在不行动，永远只能羡慕别人的博客了。</p>
</blockquote>
<p>话不多说，干起来！！<br>经过1,2的天的准备，我选择了用hexo+github 框架来搭建自己的博客。</p>
<h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p>这个直接参考其官网<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官网</a>操作即可，官网文档很详细。</p>
<h4 id="新建hexo项目"><a href="#新建hexo项目" class="headerlink" title="新建hexo项目"></a>新建hexo项目</h4><p>新建一个要存放代码的空文件夹，cmd命令进入此文件夹，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-init.png"  alt="hexo-init"></p>
<p>此时项目创建成功，项目结构如下：</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/init-suc.png"  alt="rr"></p>
<img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/init-suc.png"  class title="[图片描述]">

<h4 id="重点目录"><a href="#重点目录" class="headerlink" title="重点目录"></a>重点目录</h4><blockquote>
<p><strong>_config.yml</strong>   网站的配置信息，可以在此配置大部分的参数。<br><strong>source/_posts</strong>  存放我们编写的文档的路径<br><strong>themes</strong>   主题文件夹,你down的喜欢的主题文件都在此</p>
</blockquote>
<h4 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -g</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-g"  alt></p>
<p>命令执行后会生成public文件夹</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-g-suc.png"  alt></p>
<h4 id="查看静态页面"><a href="#查看静态页面" class="headerlink" title="查看静态页面"></a>查看静态页面</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-s.png"  alt></p>
<p>浏览器打开效果如下<br><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-s-show.png"  alt></p>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>若当前主题不是你喜欢的风格，可以更换为自己想要的风格</p>
<h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>执行以下命令，下载你喜欢的主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure>

<h4 id="查看主题"><a href="#查看主题" class="headerlink" title="查看主题"></a>查看主题</h4><p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-change-theme.png"  alt></p>
<h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><blockquote>
<p>修改站点配置文件_config.yml,把主题修改为Butterfly</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-theme-set.png"  alt></p>
<h4 id="接下来执行以下命令"><a href="#接下来执行以下命令" class="headerlink" title="接下来执行以下命令"></a>接下来执行以下命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean // 清除旧的主题</span><br><span class="line">hexo g // 生成新的主题</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>此时浏览器查看效果，会发现如下问题</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-theme-fail.png"  alt></p>
<p>对应的解决方案可以在Butterfly的Github主页看到：</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-resolve-theme.png"  alt></p>
<h4 id="执行下面命令："><a href="#执行下面命令：" class="headerlink" title="执行下面命令："></a>执行下面命令：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure>

<p>再次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h3 id="创建categories与tags"><a href="#创建categories与tags" class="headerlink" title="创建categories与tags"></a>创建categories与tags</h3><h4 id="创建categories选项"><a href="#创建categories选项" class="headerlink" title="创建categories选项"></a>创建categories选项</h4><h5 id="执行下方命令"><a href="#执行下方命令" class="headerlink" title="执行下方命令"></a>执行下方命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<h5 id="查看categories"><a href="#查看categories" class="headerlink" title="查看categories"></a>查看categories</h5><p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-22 14:47:40</span><br></pre></td></tr></table></figure>

<h5 id="添加type-“categories”"><a href="#添加type-“categories”" class="headerlink" title="添加type: “categories”"></a>添加type: “categories”</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br></pre></td></tr></table></figure>

<h5 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h5><p>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: android</span><br></pre></td></tr></table></figure>


<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。<br><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-categories-suc.png"  alt></p>
<h4 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h4><h5 id="执行下方命令-1"><a href="#执行下方命令-1" class="headerlink" title="执行下方命令"></a>执行下方命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<h5 id="查看tags"><a href="#查看tags" class="headerlink" title="查看tags"></a>查看tags</h5><p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-04-22 14:22:08</span><br></pre></td></tr></table></figure>

<h5 id="添加type-“tags”"><a href="#添加type-“tags”" class="headerlink" title="添加type: “tags”"></a>添加type: “tags”</h5><p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-tags-suc.png"  alt></p>
<h5 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h5><p>打开需要添加标签的文章，为其添加tags属性。</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-add-tags.png"  alt></p>
<blockquote>
<p><strong>这些属性和属性值之间必须有一个空格，否则解析错误。</strong></p>
</blockquote>
<h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><p>若想创建的文章分门别类的存放，便于以后查找维护，操作如下</p>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post -p tool/blog <span class="string">"hexo+github搭建个人博客"</span></span><br></pre></td></tr></table></figure>
<p><strong>‘-p’ 一定要添加，这样才会把新建的文章放到tool目录下，否则会放在_posts目录下</strong></p>
<blockquote>
<p>tool 新建文章的存放目录<br>blog 文章名字<br>“hexo+github搭建个人博客” 文章标题</p>
</blockquote>
<h4 id="生成路径如下"><a href="#生成路径如下" class="headerlink" title="生成路径如下"></a>生成路径如下</h4><p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-new-suc.png"  alt></p>
<p>现在就可以编辑blog.md文件来优化文章内容</p>
<h3 id="解决不显示图片问题"><a href="#解决不显示图片问题" class="headerlink" title="解决不显示图片问题"></a>解决不显示图片问题</h3><p>测试发现markdown编辑好的文档，在hexo里面调试的时候图片加载不出来，别着急，解决办法如下</p>
<h4 id="安装图片插件"><a href="#安装图片插件" class="headerlink" title="安装图片插件"></a>安装图片插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<h4 id="修改-config-yml配置文件"><a href="#修改-config-yml配置文件" class="headerlink" title="修改_config.yml配置文件"></a>修改_config.yml配置文件</h4><p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post -p android/bintray-release <span class="string">"通过bintray-release，发布库到Jcenter"</span></span><br></pre></td></tr></table></figure>

<p>此时会发现在android目录下多出一个与文章同名的文件夹，在此存在相关的资源文件</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-resolve-img.png"  alt></p>
<h4 id="使用图片资源语法如下"><a href="#使用图片资源语法如下" class="headerlink" title="使用图片资源语法如下"></a>使用图片资源语法如下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![](hexo-resolve-img.png)</span><br></pre></td></tr></table></figure>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>没有github账号的话，先去注册一个。在此假设你已有github账号了，进入geihub创建仓库</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github-new-repository.png"  alt><br><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github-repository-setname.png"  alt></p>
<blockquote>
<p>注意名字使用你<strong>github用户名</strong>.github.io</p>
</blockquote>
<p>现在我们已经成功的在github创建了个人博客代码存在仓库</p>
<h4 id="上传文件到github"><a href="#上传文件到github" class="headerlink" title="上传文件到github"></a>上传文件到github</h4><p>在_config.yml中添加一下repo信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/xhongy/xhongy.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h4 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h4><p>直接通过hexo来发布到github，需要安装以下插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>安装成功后，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>刷新github对应的repository页面，即可看到提交的内容</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github-upload-code.png"  alt></p>
<h4 id="浏览查看效果"><a href="#浏览查看效果" class="headerlink" title="浏览查看效果"></a>浏览查看效果</h4><p>在浏览器输入地址<a href="http://github用户名.github.io" target="_blank" rel="noopener">http://github用户名.github.io</a></p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>到此，如何使用hexo+github搭建个人博客就讲完了，现在只是借助github来部署，后续我会申请一个域名进行部署，显得更高大上一些</p>
<h1 id="期待ing…"><a href="#期待ing…" class="headerlink" title="期待ing…."></a>期待ing….</h1>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>上传文件到github</title>
    <url>/2020/04/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0github/</url>
    <content><![CDATA[<h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>首先先去  <a href="https://github.com/" target="_blank" rel="noopener">github官网</a>  注册一个账号。</p>
<p>我们使用git需要先安装git工具，<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">下载地址</a></p>
<p>接下来进入正题</p>
<h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>进入Github首页，点击New repository</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0github/new-rep.png"  alt></p>
<p>填写相应信息后点击create即可</p>
<blockquote>
<p>Repository name: 仓库名称<br>Description(可选): 仓库描述介绍<br>Public：仓库权限（公开共享，私有或指定合作者）<br>Initialize this repository with a README: 添加一个README.mdgitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignorelicense: </p>
</blockquote>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0github/rep-info.png"  alt></p>
<h4 id="仓库代码复制到本地"><a href="#仓库代码复制到本地" class="headerlink" title="仓库代码复制到本地"></a>仓库代码复制到本地</h4><p>执行相关命令将新建的仓库clone到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0github/git-add.png"  alt></p>
<h4 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h4><p>将本地要上传的代码放入刚clone下来的目录里面，cd 存放代码的路径,执行以下命令上传:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add . </span><br><span class="line">git commit -m <span class="string">"提交描述"</span></span><br><span class="line">git push -u origin master  （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入 帐号和密码）</span><br></pre></td></tr></table></figure>

<h4 id="查看上传是否成功"><a href="#查看上传是否成功" class="headerlink" title="查看上传是否成功"></a>查看上传是否成功</h4><p>此时就可以去github查看上传的代码，如下，上传成功</p>
<p><img src="/" class="lazyload" data-src="/2020/04/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0github/upload-suc.png"  alt></p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>本文是针对有计算机基础的，不是每个步骤都说的太详尽，有不明白的可在自行百度。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>切面编程</title>
    <url>/2020/04/21/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h3><p>AOP(Aspect-Oriented Pragramming),面向切面编程，是一种编程思想。Aop以切面（aspect）为基础，切面是一种新的模块化机制，用来描述分散在对象、类、或函数中的横切关点。</p>
<p>AOP 的思想是把对象的核心职责外的通用逻辑（如日志，性能，校验等）抽象出来，<br>把散布在多个对象多个模块的通用逻辑当作切面，然后动态地把代码插入到类的指定方法、<br>指定位置中，实现 AOP 的核心技术也是代码织入技术，如 AspectJ、Javassist、<br>DexMaker、ASMDex、动态代理等。</p>
<h3 id="AOP的主要功能"><a href="#AOP的主要功能" class="headerlink" title="AOP的主要功能"></a>AOP的主要功能</h3><p>AOP 是以非核心职责的通用逻辑为主的，所以主要功能是把日志记录、性能统计、<br>安全控制、事务处理、异常处理等代码从业务逻辑代码中划分出来，后面再动态织入到业<br>务逻辑中。所以 AOP 主要用于和业务逻辑相关的通用逻辑：</p>
<ul>
<li>日志记录、</li>
<li>性能统计、</li>
<li>安全控制、</li>
<li>事务处理、</li>
<li>异常处理</li>
<li>其他…</li>
</ul>
<h3 id="AspectJ术语"><a href="#AspectJ术语" class="headerlink" title="AspectJ术语"></a>AspectJ术语</h3><ul>
<li><p>Aspect ：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p>
</li>
<li><p>JPoint ：连接点，程序中可切入的点，例如方法调用时、读取某个变量时。</p>
</li>
<li><p>Pointcut ：切入点，代码注入的位置，其实就是有条件限定的JoinPoint，</p>
</li>
<li><p>例如只在特定方法中注入代码。</p>
</li>
<li><p>Advice ：在切入点注入的代码，一般有 before、after、around 三种类型，</p>
</li>
<li><p>表示代码执行前、执行后、替换目标代码，也就是在 Pointcut 何处注入代码。</p>
</li>
</ul>
<h3 id="AspectJ的使用"><a href="#AspectJ的使用" class="headerlink" title="AspectJ的使用"></a>AspectJ的使用</h3><h4 id="项目根路径-gradle-build-添加一下代码"><a href="#项目根路径-gradle-build-添加一下代码" class="headerlink" title="项目根路径/gradle.build 添加一下代码"></a>项目根路径/gradle.build 添加一下代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath &#39;org.aspectj:aspectjtools:1.9.1&#39;</span><br><span class="line">        classpath &#39;org.aspectj:aspectjweaver:1.9.1&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="项目app-buid-gradle文件中添加如下代码"><a href="#项目app-buid-gradle文件中添加如下代码" class="headerlink" title="项目app/buid.gradle文件中添加如下代码"></a>项目app/buid.gradle文件中添加如下代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.aspectj.bridge.IMessage</span><br><span class="line">import org.aspectj.bridge.MessageHandler</span><br><span class="line">import org.aspectj.tools.ajc.Main</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">final def log &#x3D; project.logger</span><br><span class="line">final def variants &#x3D; project.android.applicationVariants</span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    if (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(&quot;Skipping non-debuggable build type &#39;$&#123;variant.buildType.name&#125;&#39;.&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JavaCompile javaCompile &#x3D; variant.javaCompile</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">        String[] args &#x3D; [&quot;-showWeaveInfo&quot;,</span><br><span class="line">                         &quot;-1.8&quot;,</span><br><span class="line">                         &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                         &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                         &quot;-d&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                         &quot;-classpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                         &quot;-bootclasspath&quot;, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug &quot;ajc args: &quot; + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler &#x3D; new MessageHandler(true);</span><br><span class="line">        new Main().run(args, handler);</span><br><span class="line">        for (IMessage message : handler.getMessages(null, true)) &#123;</span><br><span class="line">            switch (message.getKind()) &#123;</span><br><span class="line">                case IMessage.ABORT:</span><br><span class="line">                case IMessage.ERROR:</span><br><span class="line">                case IMessage.FAIL:</span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.WARNING:</span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.INFO:</span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.DEBUG:</span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    implementation &#39;org.aspectj:aspectjrt:1.9.1&#39;</span><br><span class="line">    implementation project(path: &#39;:aspectjlib&#39;) &#x2F;&#x2F; 加入的依赖包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AspectJ语法示例"><a href="#AspectJ语法示例" class="headerlink" title="AspectJ语法示例"></a>AspectJ语法示例</h4><h5 id="以收集函数的执行时间，传入参数为例"><a href="#以收集函数的执行时间，传入参数为例" class="headerlink" title="以收集函数的执行时间，传入参数为例"></a>以收集函数的执行时间，传入参数为例</h5><p>先定义一个切面类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aa.aspectlib;</span><br><span class="line"></span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class MethodAspect &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;function&quot;;</span><br><span class="line">	&#x2F;&#x2F; 匹配任意方法名为&#39;getReturnInfo&#39;函数</span><br><span class="line">    private static final String getReturnInfo_POINTCUTS &#x3D; &quot;execution(* *.getReturnInfo(..))&quot;;</span><br><span class="line">    &#x2F;&#x2F; 使用 @Pointcut 来注解方法,call(MethodSignature) 关键字表示方法被调用</span><br><span class="line">    @Pointcut(getReturnInfo_POINTCUTS)</span><br><span class="line">    public void onGetReturnInfoPointcuts() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;onGetReturnInfoPointcuts()&quot;)</span><br><span class="line">    public void beforeCreate(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getTarget() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">		&#x2F;&#x2F; 获取传入的参数</span><br><span class="line">        Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">        String argsStr &#x3D; &quot;&quot;;</span><br><span class="line">        if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            argsStr &#x3D; &quot;\r\n参数：\r\n&quot;;</span><br><span class="line">            for (Object obj : args) &#123;</span><br><span class="line">                if (obj !&#x3D; null) &#123;</span><br><span class="line">                    argsStr +&#x3D; obj.toString() + &quot;\r\n&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;coco&quot;, &quot;当前类名：&quot; + joinPoint.getTarget().toString() + &quot;  方法名：&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        AopUtil.saveInfo(AopUtil.getContext(joinPoint.getThis()), joinPoint.getSignature().getName(), &quot;当前类名：&quot; + joinPoint.getTarget().toString()</span><br><span class="line">                + argsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 匹配任意方法名为&#39;asyncHttpRequest&#39;函数</span><br><span class="line">    @Before(&quot;execution(* *.asyncHttpRequest(..))&quot;)</span><br><span class="line">    public void beforeCreate1(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getTarget() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">        String argsStr &#x3D; &quot;&quot;;</span><br><span class="line">        if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            argsStr &#x3D; &quot;\r\n参数：&quot;;</span><br><span class="line">            for (Object obj : args) &#123;</span><br><span class="line">                if (obj !&#x3D; null) &#123;</span><br><span class="line">                    argsStr +&#x3D; obj.toString() + &quot;\r\n&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;coco&quot;, &quot;当前类名：&quot; + joinPoint.getTarget().toString() + &quot;  方法名：&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        AopUtil.saveInfo(AopUtil.getContext(joinPoint.getThis()), joinPoint.getSignature().getName(), &quot;当前类名：&quot; + joinPoint.getTarget().toString()</span><br><span class="line">                + argsStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="收集函数的返回值为例–-AfterReturning"><a href="#收集函数的返回值为例–-AfterReturning" class="headerlink" title="收集函数的返回值为例– AfterReturning"></a>收集函数的返回值为例– <strong>AfterReturning</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aa.aspectlib;</span><br><span class="line"></span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AfterReturningAspect &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;function&quot;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 收集方法test1和test2的返回值</span><br><span class="line">    private static final String mergePdfFiles_POINTCUTS &#x3D; &quot;execution(* *.test1(..))&quot;;</span><br><span class="line">    private static final String splitPdfFiles_POINTCUTS &#x3D; &quot;execution(* *.test2(..))&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用 @Pointcut 来注解方法,call(MethodSignature) 关键字表示方法被调用</span><br><span class="line">    @Pointcut(mergePdfFiles_POINTCUTS)</span><br><span class="line">    public void onMergePdfFilesPointcuts() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Pointcut(splitPdfFiles_POINTCUTS)</span><br><span class="line">    public void onSplitPdfFilesPointcuts() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(pointcut &#x3D; &quot;onMergePdfFilesPointcuts() || onSplitPdfFilesPointcuts()&quot;, returning &#x3D; &quot;returnValue&quot;)</span><br><span class="line">    public void afterfun(JoinPoint joinPoint, Object returnValue) &#123;</span><br><span class="line">        &#x2F;&#x2F;獲取傳入的參數</span><br><span class="line">        Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">        String argsStr &#x3D; &quot;&quot;;</span><br><span class="line">        if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            argsStr &#x3D; &quot;\r\n参数：\r\n&quot;;</span><br><span class="line">            for (Object obj : args) &#123;</span><br><span class="line">                if (obj !&#x3D; null) &#123;</span><br><span class="line">                    argsStr +&#x3D; obj.toString() + &quot;\r\n&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;coco&quot;, &quot;当前类名：&quot; + joinPoint.getTarget().toString() + &quot;  方法名：&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        AopUtil.saveInfo(AopUtil.getContext(joinPoint.getThis()), joinPoint.getSignature().getName(),</span><br><span class="line">                &quot;当前类名：&quot; + joinPoint.getTarget().toString() + argsStr + &quot;\r\n返回值：&quot;+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="以监测项目所有点击事件为例"><a href="#以监测项目所有点击事件为例" class="headerlink" title="以监测项目所有点击事件为例"></a>以监测项目所有点击事件为例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 所有的点击事件，包含正常使用、xml定义、butterknife</span><br><span class="line"> * 收集点击view所在的类，view的id，执行时间</span><br><span class="line">    * @param joinPoint</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Around(&quot;execution(* *(android.view.View))&quot;)</span><br><span class="line">   public void aroundAllMethodCall(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">       Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">       View view &#x3D; AopUtil.getViewFromArgs(args);</span><br><span class="line">       if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">           Log.d(TAG, &quot;unknown type method, so proceed it&quot;);</span><br><span class="line">           joinPoint.proceed();</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;获取View 的 string id</span><br><span class="line">       String resEntryName &#x3D; null;</span><br><span class="line">       String resName &#x3D; null;</span><br><span class="line">       resEntryName &#x3D; view.getContext().getResources().getResourceEntryName(view.getId());</span><br><span class="line">       resName &#x3D; view.getContext().getResources().getResourceName(view.getId());</span><br><span class="line"></span><br><span class="line">       AopUtil.saveInfo(AopUtil.getContext(joinPoint.getThis()),&quot;click&quot;, &quot;点前所在类：&quot; + view.getContext() + &quot;  点击view id：&quot; + resEntryName);</span><br><span class="line">       Log.e(&quot;coco1&quot;, &quot;点前所在类：&quot; + view.getContext() + &quot;  &quot; + resEntryName + &quot;  view id：&quot; + resName);</span><br><span class="line">       &#x2F;&#x2F; 执行原代码</span><br><span class="line">       joinPoint.proceed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="以监测函数运行时间为例"><a href="#以监测函数运行时间为例" class="headerlink" title="以监测函数运行时间为例"></a>以监测函数运行时间为例</h5><p>首先定义一个接口类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ...;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface TimeSpend &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义获取运行时间切面类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ...;</span><br><span class="line"></span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class MethodSpendTimeAspect &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;TIME&quot;;</span><br><span class="line">    @Pointcut(&quot;call(@com.unicom.aoplib.TimeSpend * *(..))&quot;)</span><br><span class="line">    public void methodTime() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;methodTime()&quot;)</span><br><span class="line">    public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        MethodSignature methodSignature &#x3D; (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String className &#x3D; methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">        String methodName &#x3D; methodSignature.getName();</span><br><span class="line">        String funName &#x3D; methodSignature.getMethod().getAnnotation(TimeSpend.class).value();</span><br><span class="line">        &#x2F;&#x2F;统计时间</span><br><span class="line">        long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">        Object result &#x3D; joinPoint.proceed();</span><br><span class="line">        long duration &#x3D; System.currentTimeMillis() - begin;</span><br><span class="line">        Log.e(&quot;coco&quot;, String.format(&quot;功能：%s,%s类的%s方法执行了，用时%d ms&quot;, funName, className, methodName, duration));</span><br><span class="line">        AopUtil.saveInfo(AopUtil.getContext(joinPoint.getThis()),TAG, String.format(&quot;功能：%s,%s类的%s方法执行了，用时%d ms&quot;, funName, className, methodName, duration));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在要统计运行时间的函数上加上注解<strong>@TimeSpend</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@TimeSpend</span><br><span class="line">public void test()&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抓获ANR等信息"><a href="#抓获ANR等信息" class="headerlink" title="抓获ANR等信息"></a>抓获ANR等信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aa.aspectlib;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AfterThrowAspect &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;Throwable&quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 捕获应该ANR等info</span><br><span class="line">     * 需要注意：如果目标方法中出现异常，并由catch捕捉处理且catch又没有抛出新的异常，那么针对该目标方法的AfterThrowing增强处理将不会被执行。</span><br><span class="line">     * 异常捕获</span><br><span class="line">     * @param ex</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(pointcut &#x3D; &quot;execution(* *..*(..))&quot;, throwing &#x3D; &quot;ex&quot;)</span><br><span class="line">    public void anyFuncThrows(Throwable ex) &#123;</span><br><span class="line">        StackTraceElement[] stackElements &#x3D; ex.getStackTrace();&#x2F;&#x2F;通过Throwable获得堆栈信息</span><br><span class="line">        String temp &#x3D; ex.getMessage() + &quot;\r\n&quot;;</span><br><span class="line">        if (stackElements !&#x3D; null) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; stackElements.length; i++) &#123;</span><br><span class="line">                temp +&#x3D; &quot;        &quot; + stackElements[i].toString() + &quot;\r\n&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F; 异常信息写入文件</span><br><span class="line">            AopUtil.saveInfo(AopUtil.getContext(&quot;&quot;),TAG, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>默认设置日志存放路径为 <strong>/data/user/0/包名/files</strong></p>
<p>具体查看在androidstudio里面打开Device File Explorer，开发方法如下：</p>
<p><img src="/" class="lazyload" data-src="/2020/04/21/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/file-open.png"  alt><br>在data/data 下面找到项目对应包名目录，查看文件<br><img src="/" class="lazyload" data-src="/2020/04/21/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/file-search.png"  alt></p>
<p>内容如下示例<br><img src="/" class="lazyload" data-src="/2020/04/21/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/save-info.png"  alt></p>
<h3 id="github-示例"><a href="#github-示例" class="headerlink" title="github 示例"></a>github 示例</h3><p>demo已上传github，地址如下</p>
<p><a href="https://github.com/xhongy/AspectDemo" target="_blank" rel="noopener">https://github.com/xhongy/AspectDemo</a></p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>到此，aop简单介绍已完成，因刚开始使用，写的有些片面，更多知识请自行去官网或者百度。</p>
<p>写的不对的地方，欢迎留言讨论！！</p>
]]></content>
  </entry>
</search>
